1. На етапі 3 не є проясненим спосіб створення контейнера, тому не зрозуміло, чи буде відношення між класами Detail та Details
агрегацією, чи композицією. Наразі позначимо у діаграмі це агрегацією.
Відношення між Entity та Entities також позначимо агрегацією.
Після уточнень замінимо відношення на більш відповідні.
2. Всі методи, що перевіряють допустимість прочитаних значень для полів класів Student, Subject, позначені в діаграмі + isCorrectData(): bool
3. Всі оператори порівняння (>, <, ==, >=, <=) позначені в діаграмі як + operator==(Subject&):bool
4. Порівнювати Subject будемо за цілим полем averMark. Аналогічно, порівнювати Students будемо за цілим sumaryMark.
Якщо у двох об'єктів Student або Subject співпдають головні показники сортування, то об'єкти Student сортуємо за gradebookCode,
а Subject - за name.
5. Методи, що порівнють Student та Subject, є допоміжним методом в сортуванні. Він визначає порядок сортування.
Ці методи зручно означувати за межами обох класів, щоб мати до них прямий доступ.
6. Під subjectsData будемо розуміти int summaryMark, int examMark, int termMark, int stateScaleMark, std::string subjectName.
Аналогічно, studentsData - це std::string name, std::string surname, std::string groupCode, std::string gradeBookNumber.
7. На даному етапі середній бал та стабільність предмета шукати не будемо, оскільки модифікування цих полів при читанні даних неможливе
з точки зору розробленої моделі класів. А саме: немає класу, що би відповідав за всі дані про один предмет. Натомість
є клас, що зберігає результати складання одного предмету одним студентом. 
8. Модифікуватись агреговані поля будуть в методі load класу Student, за умови успішного конструювання SubjectResult.
Це логічно, що клас сам модифікує свої поля, не передаючи цю місію іншим класам. 
9. Наразі округлення поля rating дло цілого відбувається як цілочисельне ділення суми сумарних балів на к-сть результатів.
За додаткових уточнень можливо, потрібно буде додати округлення floor або ceil.
10. Питання: чи можна використовувати функції isalpha, isdigit із ctype.h для порівняння символів при перевірці корректності вхідних даних?
11. Дружній клас, що тестує StudentResult, потрібно оголосити дружнім як в класі Student, так і в зовнішньому класі Info.
Це необхідно для того, щоб дружній клас мав доступ до членів Student((для цього декларуємо його дружнім в Student) і одночасно знав, як звернутися 
до Student(для цього декларуємо його дружнім в Info).
Звертатися до вкладених класів треба з використанням повного імені.
Поки що не знайдено способу звертатись до нестатичних полів вкладених класів із дружнього класу(але нам це і не потрібно на даному етапі)
12. Питання: Що означає "Сума оцінок"? Це число, що записано в кінці файлу з вхідними даними. (Відповідь: сума оцінок за державною шкалою)
13. Помилки під час завантаження некорректного вхідного файлу - відповідальність класів Builder та Info.
	Info відповідає за перевірку обмежень на дані у вхідному файлі (наприклад, сумарний бал має бути в межах 1-100)
	Builder відповідає за перевірку провильності формату запису даних у файлі. 